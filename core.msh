### TODO {{{
# Adjust pager line and line dividers based on screen size
# Separate personal MSH settings to dotfile
# Renaming of methods checks plugins		
# Fix mtp		
# More proactive msh-guess
# Dynamic Command Composition - Creating ow from o and w, vcap from vca and vcp		
# Split file		
# General de-numbering		
# Globally fix pglc		
# Block stdout for mr		
# Implement directory stack		
# Make menu pager friendly - enhance cds to use menu - ds to go to moded ds		
# Sensible command names		
# Usage statistics and automatic enhancement recommendation based on usage		
# Archiving system		
# Advanced post-command support		
# Completing running task beeps terminal		
# Command takes precedence over file open		
# Auto clean of STDBUF		
# }}}

#### Keymap {{{
# a : 
# b :
# c :
# d : 
# e : 
# f : Find
# g : 
# h : History
# i : 
# j : 
# k :
# l : 
# m : Move, MSH
# n :
# o : Open
# p : Print, Process
# q :
# r : Remove
# s : Search
# t : Text
# u :
# v : Version Control
# w :
# x :
# y :
# z :
# td : Todo
# }}}

#### Initialise {{{

# Record current directory {{{

if ! $NEW; then
	old_dir=$(pwd)
fi

# }}}

#}}}

#### ZSH {{{ 

# Options {{{
export HISTSIZE=10000
export SAVEHIST=10000
export HISTFILE=~/.zhistory
setopt INC_APPEND_HISTORY
setopt HIST_IGNORE_DUPS
setopt EXTENDED_HISTORY     
setopt AUTO_PUSHD
setopt PUSHD_IGNORE_DUPS
setopt HIST_IGNORE_SPACE
setopt NO_NOMATCH
setopt NO_NOTIFY
# }}}

# Color {{{
autoload colors
colors
for color in BLACK RED GREEN YELLOW BLUE MAGENTA CYAN WHITE; do
eval BR$color='$terminfo[bold]$fg[${(L)color}]'
eval PBR$color='%{$terminfo[bold]$fg[${(L)color}]%}'
eval BRBG$color='$terminfo[bold]$bg[${(L)color}]'
eval PBRBG$color='%{$terminfo[bold]$bg[${(L)color}]%}'
eval $color='$fg[${(L)color}]'
eval BG$color='$bg[${(L)color}]'
eval P$color='%{$fg[${(L)color}]%}'
(( count = $count + 1 ))
done
FINISH="[m"
PFINISH="%{$terminfo[sgr0]%}"
# }}}

# Prompt {{{  

autoload -U add-zsh-hook

add-zsh-hook precmd msh-assist
#add-zsh-hook preexec o_preexec

# (Internal) Shell : Top Prompt
# _stp : Show top prompt
_stp() {
  _stp_id
  _stp_command
}

# _stp_id : Show shell identifier in top prompt
_stp_id() {
	# TODO Because this (hostname) is called from zle, vt is very slow - How to deal with this?
	stp_disk_color=$BRCYAN
	if ! evn "dfr | s G" || [[ $(dfr | cut -dG -f1) -le 10 ]]; then
		stp_disk_color=$RED
	fi
  msh_color=$BRCYAN
  msh_status="Up to date"
  for package in $MSH/*; do
    if [[ $(rnode $package / 0) == "msh-"* && $(rnode $package / 0) != "msh-rc" ]]; then
      sb git -C $package fetch upstream
      if [[ $(git -C $package rev-parse upstream/master) != $(git -C $package rev-parse HEAD) ]]; then
        msh_color=$RED
        msh_status="Outdated"
        break
      fi
    fi
  done
	e " ${BRCYAN}MSH $$ @ $(hostname) |$FINISH$stp_disk_color Free disk: $(dfr)$FINISH | ${msh_color}MSH $msh_status$FINISH"
}

# _stp_command : Show command input and intepretation in top prompt
_stp_command() {
  stp_hr=$(printf '-%.0s' {1..$(($(sw)))})
  e $BRCYAN$stp_hr$FINISH
  usr_line="${BLUE} USR: $MSH_INTER"
  pwd_lth=$(echo $LAST_PWD | wc -c)
  usr_line_lth=$(echo $usr_line | decolor | wc -c)
  printf  "$usr_line%*s$BRCYAN$LAST_PWD$FINISH\n" $(( $(sw) - $usr_line_lth - $pwd_lth + 1 ))
  e $BRCYAN$stp_hr$FINISH
  e "${MAGENTA} MSH: $MSH_REPLY$FINISH"
  e $BRCYAN$stp_hr$FINISH
  e $GREEN MOS: $FINISH
}

# Window Title
wt() {
	if [[ $1 != "" ]]; then
		wtl $1
	else
		wtu
	fi
}

# Window Title Lock
# Set tmux window title and prevent further changes
wtl() {
  if [[ $1 != "" ]]; then
    wtt $1
  fi
  MSH_WT=false
}

# Window Title Unlock
# Set tmux window title and allow further changes
wtu() {
  MSH_WT=true
  if [[ $1 != "" ]]; then
    wtt $1
  fi
}

# Test whether tmux window title is allowed to change
wt_test() {
  e $MSH_WT
}

# Window Title Temporary
wtt() {
  if $(wt_test); then
    print -Pn "\033k$1\033\\"
  fi
}

# (Internal) MSH : Assist
msh-assist() {
  vbcp=$(vbcp)
	case $(vt) in
		GIT) MSH_ASSIST="We're in a git repository.${FINISH} Branch $(if vsv | s clean &> /dev/null; then e ${GREEN}$(vbc) (clean)${FINISH}; elif vsv | s untracked &> /dev/null; then e ${RED}$(vbc) (untrakced)${FINISH}; else e ${RED}$(vbc) (dirty)${FINISH}; fi) $(if [[ $vbcp == "" ]]; then e ${GREEN}branch is root${FINISH}; fi)$(if [[ $(vbmdic) != 0 ]]; then e ${RED}$(vbmdic) behind $vbcp ${FINISH}; fi)$(if [[ $(vbmdoc) != 0 ]]; then e ${YELLOW}$(vbmdoc) ahead of $vbcp ${FINISH}; fi)$(if [[ $vbmc != "" && $(vbmdoc) == 0 && $(vbmdic) == 0 ]]; then e ${GREEN}identical to $vbcp ${FINISH}; fi)";;
		SVN) MSH_ASSIST="We're in a svn repository.";;
		N/A) MSH_ASSIST="We're not under version control.";;
	esac
	e
	e $BRCYAN$stp_hr$FINISH
	e $MAGENTA MSH: $MSH_ASSIST $FINISH
	e $BRCYAN$stp_hr$FINISH
}

# TODO Tab to expand current word - progress guess
msh-guess() {
	USR_INPUT=$(echo $BUFFER | head -1)
	BUFFER=$USR_INPUT

	if [[ $BUFFER == "" ]]; then
		unset MSH_GUESS
		unset MSH_HELP
	else
# Try to match a file
		if [[ "$(echo *${BUFFER}*)" != "*${BUFFER}*" ]] && evn "lfd $MSH_GUESS_INDEX *$BUFFER*"; then
			MSH_GUESS=$(eve "lfd $MSH_GUESS_INDEX *$BUFFER*")
#			elif evn "lfd $MSH_GUESS_INDEX $(rnode \"$BUFFER\" \" \" 0)*"; then
#			  MSH_GUESS=$(eve "lfd $MSH_GUESS_INDEX $(rnode \"$BUFFER\" \" \" 0)*")
#	Match a history
		else
			MSH_GUESS=$(chd "$BUFFER" $MSH_GUESS_INDEX)
		fi

		MSH_HELP=$(mh $(echo $USR_INPUT | cut -f1))
		if [[ $MSH_HELP == "" ]]; then
			MSH_HELP=$(mhv $(echo $USR_INPUT | cut -f1))
		fi
		MSH_HELP=$(e $MSH_HELP | ts "^" "      " | ts "# ")
	fi

	if [[ $MSH_GUESS != "" ]]; then
		BUFFER_CHAR=$(echo $BUFFER | wc -c)
		BUFFER+="
 MSH: $MSH_GUESS ?"
		region_highlight=("$BUFFER_CHAR $#BUFFER fg=magenta");
	fi

	if [[ $MSH_HELP != "" ]]; then
		BUFFER_CHAR=$(echo $BUFFER | wc -c)
		BUFFER+="

      By the way, here's some information about $(echo $USR_INPUT | cut -f1):"
		region_highlight+=("$BUFFER_CHAR $#BUFFER fg=cyan,bold");

		BUFFER_CHAR=$(echo $BUFFER | wc -c)
		BUFFER+="
$MSH_HELP"
		if [[ $MSH_HELP == *"not found"* ]]; then
			region_highlight+=("$BUFFER_CHAR $#BUFFER fg=yellow");
		else
			region_highlight+=("$BUFFER_CHAR $#BUFFER fg=green");
		fi
	fi

}

msh-guess-first() {
  MSH_GUESS_INDEX=1
  msh-guess
}
self-insert() {
  zle .self-insert
  msh-guess-first
}
zle -N self-insert
backward-delete-char() {
  zle .backward-delete-char
  msh-guess-first
}
zle -N backward-delete-char
vi-backward-delete-char() {
  zle .vi-backward-delete-char
  msh-guess-first
}
zle -N vi-backward-delete-char
delete-char() {
  zle .delete-char
  msh-guess-first
}
zle -N delete-char
vi-delete-char() {
  zle .vi-delete-char
  msh-guess-first
}
zle -N vi-delete-char

msh-guess-next() {
  (( MSH_GUESS_INDEX = $MSH_GUESS_INDEX + 1 ))
  msh-guess
}
zle -N msh-guess-next
bindkey "^N" msh-guess-next

msh-guess-previous() {
  (( MSH_GUESS_INDEX = $MSH_GUESS_INDEX - 1 ))
  msh-guess
}
zle -N msh-guess-previous
bindkey "^P" msh-guess-previous

msh-personality() {
# Intepretation
  if [[ $BUFFER == "" ]]; then
    MSH_INTER="Go home"
  else
    MSH_INTER=$BUFFER
  fi
# Reply (This should stop the execution of the command)
  if [[ $BUFFER == $LAST_BUFFER ]]; then
    MSH_REPLY="You're nagging again.."
  elif [[ $BUFFER == "Hello" ]]; then
    MSH_REPLY="Hey. By the way - you're hardly this polite. Is everything OK?"
  elif [[ $LAST_BUFFER == "Hello" && $BUFFER == "No" ]]; then
    MSH_REPLY="Oh.. What's wrong?"
  elif [[ $LAST_BUFFER == "No" ]]; then
    MSH_REPLY="OK. Good luck."
  elif [[ $BUFFER == "I like you" ]]; then
    MSH_REPLY="Aww.. How sweet of you :)"
  elif [[ $BUFFER == "I like"* ]]; then
    MSH_REPLY="I like it too"
  elif [[ $BUFFER == *"Haoyang"* ]]; then
    MSH_REPLY="I think Haoyang is a genius."
  elif [[ $BUFFER == "how to"* ]]; then
    MSH_REPLY="Let me see if I can help you.."
    msh-help
  else
    MSH_REPLY="OK"
  fi
}

msh-help() {
  if ! evn which how2; then
    pin how2
  fi
  BUFFER=$(e $BUFFER | ts "how to" "how2" | ts " in " " -l ")
}

msh-enter() {
  wtt $(lnode $BUFFER " " 1)
  msh-personality
  LAST_BUFFER=$BUFFER
  LAST_PWD=$(pwd)
  cs
  zle expand-word
# Empty = go home
  if [[ $BUFFER == "" ]]; then
    BUFFER="d"
# Open immediate file with full name
  elif [[ -a $BUFFER || $BUFFER = "-" ]]; then 
    BUFFER="o $BUFFER"
  else
    BUFFER=$LAST_BUFFER
# Run command if valid
    if which $(lnode $BUFFER " " 1) &> /dev/null; then
			e $BUFFER >> $MSH_HISTCMD
# Inject pipes into pn the command involves pn
# FIXME Slight issue where indirect pn usage are not discovered such as `l` using `la` or `lb` indirectly
			if which $(lnode $BUFFER " " 1) | grep pn &> /dev/null && [[ $BUFFER == *"|"* ]] &> /dev/null; then
				PN_PIPE="|"$(e $BUFFER | cut -d"|" -f2-)
				BUFFER=$(e $BUFFER | cut -d"|" -f1)
			else
				unset PN_PIPE
			fi
# Open immediate file with partial match
		elif [[ "$(echo *${BUFFER}*)" != "*${BUFFER}*" ]]; then
			BUFFER="o *${BUFFER}*"
			zle expand-word
# Find file with abbreviated match
		else
			BUFFER="fpa $BUFFER"
		fi
  fi
  zle accept-line
}

msh-accept-guess() {
# Accept guess 
  BUFFER=$MSH_GUESS
  msh-enter
}
zle -N msh-accept-guess
bindkey "^@" msh-accept-guess

msh-expand-guess() {
	BUFFER=$MSH_GUESS
}
zle -N msh-expand-guess
bindkey "^G" msh-expand-guess

msh-new-command() {
# Remove guess
  BUFFER=$(echo $BUFFER | head -1)
  msh-enter
}
zle -N msh-new-command
bindkey "\r" msh-new-command

msh-expand() {
  BUFFER=$(tn $BUFFER)
}
zle -N msh-expand
bindkey "^E" msh-expand

msh-history() {
  BUFFER=$(echo $BUFFER | head -1)
  BUFFER="ch $BUFFER"
  msh-enter
}
zle -N msh-history
bindkey "^H" msh-history

msh-forward() {
  BUFFER=n
  msh-enter
}
zle -N msh-forward
bindkey "^F" msh-forward

msh-backward() {
  BUFFER=p
  msh-enter
}
zle -N msh-backward
bindkey "^B" msh-backward

msh-right() {
  BUFFER=pgr
  msh-enter
}
zle -N msh-right
bindkey "^J" msh-right

msh-left() {
  BUFFER=pgl
  msh-enter
}
zle -N msh-left
bindkey "^K" msh-left

PROMPT="${PBLUE} USR: ${PFINISH}"
RPROMPT="${PBRCYAN}%/${PFINISH}"

# }}}

# Editor {{{
export EDITOR=vim
bindkey -M vicmd '?' history-incremental-search-backward
# }}}

# Syntax {{{
#setopt extended_glob
#TOKENS_FOLLOWED_BY_COMMANDS=('|' '||' ';' '&' '&&' 'sudo' 'do' 'time' 'strace')
# 
#recolor-cmd() {
#   region_highlight=()
#   colorize=true
#   start_pos=0
#   for arg in ${(z)BUFFER}; do
#       ((start_pos+=${#BUFFER[$start_pos+1,-1]}-${#${BUFFER[$start_pos+1,-1]## #}}))
#       ((end_pos=$start_pos+${#arg}))
#       if $colorize; then
#           colorize=false
#           res=$(LC_ALL=C builtin type $arg 2>/dev/null)
#           case $res in
#               *'reserved word'*)   style="fg=magenta";;
#               *'alias for'*)       style="fg=cyan";;
#               *'shell builtin'*)   style="fg=yellow";;
#               *'shell function'*)  style='fg=green';;
#               *"$arg is"*)
#                   [[ $arg = 'sudo' ]] && style="fg=red" || style="fg=blue";;
#               *)                   style='none';;
#           esac
#           region_highlight+=("$start_pos $end_pos $style")
#       fi
#       [[ ${${TOKENS_FOLLOWED_BY_COMMANDS[(r)${arg//|/\|}]}:+yes} = 'yes' ]] && colorize=true
#       start_pos=$end_pos
#   done
#}
#
#
#backward-delete-char() { zle .backward-delete-char && recolor-cmd }
# 
#zle -N backward-delete-char
# }}}

# Options {{{
#setopt NULL_GLOB
# }}}

# Development Environment {{{
#PATH=$PATH:$HOME/.rvm/bin:~/bin # Add RVM to PATH for scripting
#source ~/.rvm/scripts/rvm

# }}}

# Completion {{{

#. $MOS_ROOT/src/zsh-autosuggestions/autosuggestions.zsh
#zle-line-init() {
#  zle autosuggest-start
#}
#zle -N zle-line-init
#bindkey '^T' autosuggest-toggle


#autoload predict-on
#predict-toggle() {
#    ((predict_on=1-predict_on)) && predict-on || predict-off
#}
#zle -N predict-toggle
#bindkey '^T' predict-toggle
#zstyle ':predict' toggle true
#zstyle ':predict' verbose true

# }}}

#}}}

#### MSH {{{

export MSH_LS_AUTO_MODE=false
export MSH_AUTO_EXCLUDE=true
export MSH_AUTO_EXCLUDE_GLIST=".svn,.git,testsrc,target,.classpath,node_modules,bower_components,lib"
export MSH_AUTO_EXCLUDE_FLIST="! -path '*/.svn/*' ! -path '*/target/*' ! -path '*/testsrc/*' ! -path '*/classes/*'"
export MSH_AUTO_EXCLUDE_TLIST=".svn|testsrc|target|.classpath|node_modules|.git|lib|bower_components"
export MSH_PREFERRED_REPOSITORY_TYPE=GIT

export MSH=~/msh
export MSH_CORE=$MSH/msh-core/core.msh
export MSHRC=~/.mshrc

# Load Core Configurations {{{

mkdir -p $MSH/msh-rc
cd $MSH/msh-rc
if [[ ! -a msh-core.mshrc ]]; then
  cp $MSH/msh-core/msh-core.mshrc .
  vi msh-core.mshrc
fi
source msh-core.mshrc

# }}}

# MSH : Modules
# mm : Open msh modules
mm() {
  o $MSH
}

# TODO Could be started by loading a bootstrapping msh which also indexes available msh modules
# MSH : Reload
# mr : Reload MSH
mr() {
  source $MSH_CORE
}

# MSH : Edit
# me : Edit MSH core
# me java : Edit msh-java module
# me sl : Edit the command 'sl'
me() {
  echo ":set foldmethod=marker" > $MOS_TMP/rc.vi
  if [[ $1 == "" ]]; then
		module=core
  elif [[ -d $MSH/msh-$1 ]]; then
		module=$1
	else
		command=$1
		echo "zR/^$1(" > $MOS_TMP/rc.vi
		module=$(grep ^$command\( $MSH -r --include="*.msh" | ts .*msh- | cut -d/ -f1)
		if [[ $(echo $module | wc -l) > 1 ]]; then
			pn me "grep ^$command\( $MSH -r --include="*.msh" | ts .*msh- | cut -d/ -f1"
			return
		fi
  fi
	vi $MSH/msh-$module/$module.msh -s "$MOS_TMP/rc.vi"
	mr
}

# MSH : Configure
# mc : Configure msh-core.mshrc in msh-rc
# mc java : Configure msh-java.mshrc in msh-rc
mc() {
  if [[ $1 == "" ]]; then
    module=core
  else
    module=$1
  fi
  vi $MSH/msh-rc/msh-$module.mshrc
}

# MSH : Configure Variable
# mcv PAGER_SIZE 200 : Change variable PAGER_SIZE to 200 in the core module
# mcv JPJ inv2 kiwiplan :  Change variable JPJ to inv2 in the kiwiplan module
mcv() {
	if [[ $3 == "" ]]; then
    module=core
	else
    module=$3
	fi
  rc_file=$MSH/msh-rc/msh-$module.mshrc
	rep=$(echo $2 | esr)
	sed -i.sedbak 's/^export '$1'=.*$/export '$1'='$rep'/g' $rc_file
	r $rc_file.sedbak
	mr
}

# MSH : Install
# mi haoyangnz node : Install MSH module "msh-node" from haoyangnz's github repository msh-node
mi() {
  git clone git@github.com:$1/msh-$2.git $MSH/msh-$2
	mr
}

# MSH : Upgrade
# mu : Upgrade all MSH packages
mu() {
	for package in $(ls $MSH); do
    if [[ $package == "msh-rc" ]]; then
      continue
    fi
    cd $MSH/$package
    e "${GREEN}Upgrading $package..${FINISH}"
    if ! evn git remote show upstream; then
      e "${RED}There's no upstream configured to upgrade from."
      e "Please enter a github owner to use their $package as the upstream to upgrade from, or press enter to skip the upgrade for this module:${FINISH}"
      read upstream_owner
      if [[ $upstream_owner == "" ]]; then
        e "${YELLOW}Skipped the upgrades for $package${FINISH}"
        e
        continue
      fi
      git remote add upstream https://github.com/$upstream_owner/$package.git
    fi
    git fetch upstream
    git checkout master
    git merge upstream/master
    e "${GREEN}Upgraded $package.${FINISH}"
    e
	done
  e "${GREEN}All upgrades complete. Press enter to reload the upgraded packages. ${FINISH}"
	read
  e "${GREEN}Reloading the upgraded packages..${FINISH}"
	mr
}

# MSH : Build
# mb : Run tests on the current MSH library
mb() {
	# Prepare work directory
  pwd=$(pwd)
  dsb
  d rt
  cs

	# Perform regression test
  result=PASSED
  e --- Starting RT

	# Remove work directory
  cd $pwd
  if [[ $result == "FAILED" ]]; then
    e --- RT FAILED
    return 1
  fi
  e --- RT PASSED
}

# MSH : Configuration Diff
# mcd : Show diff for MSH library changes
mcd() {
  pushd .
  cd $MSH
	for plugin in $(ls); do
		cd $plugin
		dt
		cd ..
	done
  popd
}

# MSH : Plugin Configuration Diff
# mpcd java : Show diff for msh-java plugin changes
mpcd() {
  pushd .
  cd $MSH/msh-$1
	dt
  popd
}

# MSH : Core Publish
# mp "New command sl" : Commit and push MSH core changes to upstream if build succeeds
mcp() {
  if ! mb; then
    e Commit ommitted due to build failure.
    return
  fi
  pushd .
  cd $MSH
  vcap $1
  popd
}

# MSH : Plugin Publish
# mpp java "New command b" : Commit and push MSH plugin changes to upstream if build succeeds
mpp() {
  pushd .
  cd $MSH/msh-$1
  vcap $2
  popd
}

# MSH : Publish
# mp "Fixed the mp doc" : Publishes changes to all msh modules with the commit message "Fixed the mp doc"
mp() {
	mcp $1
	for plugin in $(ls $MSH); do
		mpp $(echo $plugin | cut -c5-) $1
	done
}

# MSH : Help
# mh sl : Show the documentation of command sl
mh() {
  cat $MSH/msh-*/*.msh | sc "^$1\(" -B2 | head -2
}

# MSH : Help Verbose
# mhv sl : Show the documentation and code of command sl
mhv() {
	mh $1
  w $1
}

# # MSH : List
# ml grep : List all command documentation with the keyword grep
ml() {
  pattern="#.*$(kw $@)"
  cat $MSH/msh-*/*.msh | si "\(\)" | si "^$" | si "\{\{\{" | s -C1 "$pattern"
}

# }}}

#### General OS {{{

# Core Environment variables {{{

# OS can be GNU or BSD
case $(uname) in
	Darwin) export OS=BSD;;
	*) export OS=GNU;;
esac

# TODO Move personal stuff to prc
export PASS=TODO
export PRINTER=Canon_LBP6780_3580_UFR_II
export BEEP=/usr/share/sounds/ubuntu/stereo/message-new-instant.ogg
export LANG=en_NZ.UTF-8
export PATH=.:$PATH

export MOS_ROOT=~/mos

export WORK=$MOS_ROOT/work
export COMMON=$MOS_ROOT/common
export SANDBOX=$MOS_ROOT/sandbox
export NOTE=$MOS_ROOT/note
export MOS_BIN=$MOS_ROOT/bin
export MOS_LIB=$MOS_ROOT/lib
export MNT=$MOS_ROOT/mnt

export MOS_TMP=$WORK/.tmp
export STDOUT=$MOS_TMP/stdout/$$
export STDERR=$MOS_TMP/stderr/$$
export STDBUF=$MOS_TMP/stdbuf/$$
export MSH_HISTCMD=$MOS_TMP/HISTCMD
export MSH_HISTOPEN=$MOS_TMP/HISTOPEN
export MSH_HISTOPENFILE=$MOS_TMP/HISTOPENFILE

[[ $OS == "BSD" ]] && export CLICOLOR_FORCE=1

# }}}

# Core Aliases {{{

alias pls='sudo $(!!)'

alias beep='paplay $BEEP'

alias bc='bc -l'
alias emacs='emacs -nw'
alias vi='vim'

case $OS in
  GNU) alias lscolor='ls --color'
	     alias lsnocolor='ls --color=none';;
	BSD) alias lscolor='gls --color'
	     alias lsnocolor='gls --color=none';;
esac

# }}}

# Utility functions {{{


# Left Node
# lnode a/b/c/d / 2 : Split a/b/c/d by delimiter / to [a,b,c,d] and obtain the second substring b
lnode() {
  echo $1 | cut -d $2 -f $3
}

# Right Node
# rnode a/b/c/d / 2 : Split a/b/c/d by delimiter / to [a,b,c,d] and obtain the second to last substring b (0 based)
rnode() {
  echo $1 | cut -d $2 -f $(echo "$(echo $1 | s -o $2 | wc -l) + 1 - $3" | bc)
}

# Print previous command
pc() {
  fc -nl 1 | si "^[ef]?[0-9]*$" | tail -1
}

# Run previous command
rpc() {
  eval $(pc)
}

# Produce a numbered menu from the ouput of a command and return the selected line
# $@ the command to execute
menu() {
  eval $@ | nl
  read n
  menu=$(eval $@ | sed -n "$n"p | decolor)
}

# Start second-level cron job
# TODO Make friendly with pager
scron() {
  if [[ $2 = "" ]]; then
    SLEEP_TIME=1;
  else
    SLEEP_TIME=$2
  fi
  while true; do
    evb $1
    clear
    catb
    sleep $SLEEP_TIME;
  done 
}

# Start second-level cron daemon
# TODO Make friendly with pager
scrond() {
  if [[ $2 = "" ]]; then
    SLEEP_TIME=1;
  else
    SLEEP_TIME=$2
  fi
  while true; do
    evn $1
    sleep $SLEEP_TIME;
  done &
}

# Execute a command with the arguments from a file and open the output in vi
# $1 command to execute
# $2 file that contains all the arguments
# exe sqle queries : Execute sqle with every line in the file "queries" as argument
exe() {
  while read args; do
    echo $1 $args
    $1 $args
    echo
  done < $2
}

# Remove line numbers
unl() {
  cut -f2-
}

# Date : Timestamp
# timestamp : Show current time stamp in nano second
timestamp() {
  date +%s%N
}

# }}}

# Text {{{

# Text : Keyword
# kw one two three : Outputs "one.*two.*three"
kw() {
  echo $@ | sed "s/ /.*/g"
}

# Text : Full PascalCase Abbreviation
# Form a regex for full PascalCase abbreviation
ab() {
  var=`echo $1 | sed 's/./&[abcdefghijklmnopqrstuvwxyz]*/g'`
  echo "${var}\..*"
}

# Text : Partial Abbreviation
# Form a regex for partial abbreviation
pab() {
  var=`echo $1 | sed 's/./&.*/g'`
  echo $var
}

# Text : Escape Sed Replacement
# Escape for sed replacement
esr() {
 sed -e 's/[\/&]/\\&/g'
}

# Text : Escape Regex
# Escape for regex
esk() {
  sed -e 's/[]\/(){}$*.^|[]/\\&/g'
}

# Text : Substitute
# ts apple pear : Substitute apple with pear
ts() {
	sed "s/$1/$2/g"
}

# Text : Until Inclusive
# tui apple : Remove everything after the first occurrence of "apple"
tui() {
	sed "/$1/q"
}

# Text : Until Exclusive
# tue apple : Remove everything from the first occurrence of "apple"
tue() {
	sed "/$1/,$ d"
}

# }}}

# Pager {{{

# Pager : Pager Print
# pgp : Print the current page
pgp() {
  if $MSH_PAGER_ON; then
    cs && echo
    e $GREEN $(($PAGER_TOP / $PAGER_SIZE + 1))/$(($(catb | wc -l) / $PAGER_SIZE + 1)) (+$PAGER_LEFT) $FINISH${BRRED}Selected:$SI$FINISH
    #catb | cut -c -170 | nl | al $PAGER_TOP $PAGER_BOTTOM
    catb | perl -pe 's/^((?:(?>(?:\e\[.*?(m|K))*).){0,'$PAGER_LEFT'})((?:(?>(?:\e\[.*?(m|K))*).){0,'$(($(sw) - 10))'}).*/$3\e[m/' | nl | al $PAGER_TOP $PAGER_BOTTOM
  fi
}

# Pager : Pager Line Count
# pglc : Print the total number of lines in the pager buffer
pglc() {
  catb | wc -l
}

# Pager : Pager
# pg : Print the first page
pg() {
  PAGER_TOP=1
  PAGER_BOTTOM=$PAGER_SIZE
	PAGER_LEFT=0
  pgp
}

# Pager : Right
# pgr : Scroll the pager to the right
pgr() {
  (( PAGER_LEFT += $(($(sw) - 10))/2 ))
  pgp
}

# Pager : Left
# pgl : Scroll the pager to the left
pgl() {
  (( PAGER_LEFT -= $(($(sw) - 10))/2 ))
  pgp
}

# Pager : Pager Next
# n : Print the next page
n() {
  (( PAGER_TOP += $PAGER_SIZE ))
  (( PAGER_BOTTOM += $PAGER_SIZE ))
  pgp
}

# Pager : Pager Previous
# p : Print the previous page
p() {
  (( PAGER_TOP -= $PAGER_SIZE ))
  (( PAGER_BOTTOM -= $PAGER_SIZE ))
  pgp
}

# }}}

# Shell {{{

# Shell : Test
# st "[[ -a src ]]" : Test if src exists, and print the result
st() {
  eval $1 && e \"$1\" is true || e \"$1\" is false
}

# Shell Variable : Back Up
# svbu MSH : Back up the value of the shell variable $MSH to $MSH_BU
svbu() {
  eve export $1_BU=\$$1
}

# Shell Variable : Back Up Remove
# svbur MSH : Back up the value of the shell variable $MSH to $MSH_BU, and unset $MSH
svbur() {
  eve export $1_BU=\$$1
  unset $1
}

# Shell Variable : Put Back
# svpb MSH : Put back the value of the shell variable $MSH from $MSH_BU
svpb() {
  eve export $1=\$$1_BU
}

# Shell Variable : Put Back Remove
# svpbr MSH : Put back the value of the shell variable $MSH from $MSH_BU, and unset $MSH_BU
svpbr() {
  eve export $1=\$$1_BU
  unset $1_BU
}

# Shell : Background
# sb git pull : Run "git pull" in a background process without disrupting the foreground shell's I/O streams
sb() {
  (evn "$@" &)
}

# Shell : Width
# sw : Prints terminal width (number of character across)
sw() {
  tput cols
}

# }}}

# System functions {{{

# Clear Screen
cs() {
  clear
  _stp
}

msh-clear() {
  BUFFER=cs
  msh-enter
}
zle -N msh-clear
bindkey "^L" msh-clear


clip() {
  xclip -sel clip
}

decolor() {
  sed "s/\[\([0-9]\{1,2\}\(;[0-9]\{1,2\}\)\{0,1\}\)\{0,1\}[m|K]//g" $@
}

# Evaluate : Evaluate to Buffer
# evb : evaluate
evb() {
  eval "$@" &> $MOS_TMP/stdbuf/$$
  decolor $MOS_TMP/stdbuf/$$ > $MOS_TMP/stdbuf/$$.nocolor
}

catb() {
  cat $MOS_TMP/stdbuf/$$
}

catbnc() {
  cat $MOS_TMP/stdbuf/$$.nocolor
}

catlb() {
  catl $MOS_TMP/stdbuf/$$ $1
}

catlbnc() {
  catl $MOS_TMP/stdbuf/$$.nocolor $1
}

cato() {
  c $STDOUT
}

cate() {
  c $STDERR
}

evn() {
  eval $@ &> /dev/null
}

w() {
  which $@
}

wn() {
  evn w $@
}

# Package : Install
# pi zsh : Instal the "zsh" package
pi() {
  e --- Installing $@
  case $OS in
      GNU) sudo apt-get -y install $@;;
      BSD) brew install $@;;
  esac
}

# Package : Install Node
# pin how2 : Install the npm package "how2" globally
pin() {
  if evn which npm; then
    e --- Installing node package $@
    npm install -g $@
  else
    e You need to install nodejs and npm first before you can install any node packages.
  fi
}

# Package : Uninstall
# pu zsh : Uninstall the "zsh" package
pu() {
  e --- Uninstalling $@
  sudo apt-get remove $@
}

# }}}

# File {{{

# Cat
c() {
  if [[ -f $1 ]]; then
    cat $1;
  fi
}

cr() {
	case $OS in
			GNU) tac $@;;
			BSD) tail -r $@;;
	esac
}

# Tar

z() {
	if [[ $1 == "" ]]; then
		tar cvfz $(rnode $(pwd) / 0).tar.gz *
	elif [[ $2 == "" ]]; then
		tar cvfz $1.tar.gz $1
	else
		tar cvfz $1.tar.gz ${@:2}
  fi
}

zr() {
	z $@
	if [[ $1 == "" ]]; then
		r *
	elif [[ $2 == "" ]]; then
		r $1
	else
		r ${@:2}
  fi
}

# Unzip
uz() {
  for target in $@; do
    echo $target
    if [[ $target = *.tar.gz ]]; then
      tar xvfz $target
      r $target
    elif [[ $target = *.gz ]]; then
      gunzip $target
      r $target
    elif [[ $target = *.tar ]]; then
      tar xvf $target
      r $target
    elif [[ $target == *.bz2 ]]; then
      bunzip2 $target
      r $target
    fi
  done
}

# Back Up : Back Up
bu() {
  if [[ $2 = "" ]]; then
    cp -r $1 $1.bak
  else
    cp -r $1 $1.bak.$2
  fi
  l
}

# Back Up : Back Up Remove
bur() {
  for file in $@; do
    mv $file $file.bak
  done
}

# TODO pbr
# Back Up : Put Back
pb() {
  r $1
  if [[ $2 == "" ]]; then
    cp -r $1.bak $1
  else
    cp -r $1.bak.$2 $1
  fi
}

pbr() {
  if [[ $1 == "" ]]; then
    _pbr *.bak
  else
    _pbr $@
  fi
  l
}

_pbr() {
  for file in $@; do
    if [[ $file == *.bak ]]; then
      mtp $file "$(echo \$f | ts .bak)"
    else
      m $file.bak $file
    fi
  done
}

# Tree
t() {
  if $MSH_AUTO_EXCLUDE; then
    pn t "tree -fC --noreport -I \"$MSH_AUTO_EXCLUDE_TLIST\" $@"
  else
    pn t "tree -fC --noreport $@"
  fi
}

tl() {
  pn t "tree -f --noreport -L $1 ${@:2}"
}

for ((i = 0; i < 100; i++)); do
  alias t$i="tl $i"
done

# Tree diff
tdiff() {
  d $1
  tree > $MOS_TMP/tdiff.1
  d -
  d $2
  tree > $MOS_TMP/tdiff.2
  d -
  vimdiff $MOS_TMP/tdiff.1 $MOS_TMP/tdiff.2
  rm $MOS_TMP/tdiff.1
  rm $MOS_TMP/tdiff.2
}

function command_not_found_handler() {
  cs
}

# List Utility : List
# l : List files in full or brief depending on total number of files
l() {
  MSH_PAGER_ON=true
  if $MSH_LS_AUTO_MODE && [[ $(la $@ | wc -l) -lt 30 ]]; then
    la $@
  else
    lb $@
 fi
}

# List Utility: List All
# la : List almost all files
la() {
  pn l "lscolor -ltuhA $@ | si ^total"
	wtt $(rnode $(pwd) "/" 0)
}

# List Utility: List Brief
# lb : List files in brief
lb() {
  pn l "lscolor -ltuh $@ | si ^total"
  wtt $(rnode $(pwd) "/" 0)
}

# List Utility: List Hidden
# lh : List hidden files
lh() {
  pn l "lscolor -ltuhd .*"
  wtt $(rnode $(pwd) "/" 0)
}

# List : List Filtered
# lf : List files with filename pattern filter
lf() {
  pn l "lscolor -ltuhd $@"
  wtt $(rnode $(pwd) "/" 0)
}

lfd() {
  lsnocolor -tuhd ${@:2} | head -$1 | tail -1
}

# Disk : Link
# dl a/b : Create shortcut b pointing to a/b (shortcut name is taken from leaf of destination)
# dl a/b c : Create shortcut c pointing to a/b
dl() {
  ln -fs $@
}


# Move : Move
# m a b c : Move a and b to c
# m * "*.tar" : add .tar after all files
m() {
	if [[ $@[-1] == *"*"* ]]; then
		mtp ${@:1:-1} "$(echo $@[-1] | ts \* \$f)"
	else
		mv ${@:1:-1} $@[-1]
	fi
  l
}

# Move : Move Text Process
# mtp *man* "$(echo \$f | ts man mapman)" : Replace *man* with *mapman*
mtp() {
	for f in ${@:1:-1}; do
		eve "mv $f $@[-1]"
	done
}

# Move : Move Make Directory
# mmd a b c : Make directory c, and move a and b to c
mmd() {
	md $@[-1]
	m $@
}

# Move : Move Shortcut
# ml a b c : Move a and b to c, and create symbolic links from a and b to c/a and c/b
ms() {
  m $@
  for file in ${@:1:-1}; do
    dl $@[-1]/$file
  done
  l
}

export TRASH=$MOS_ROOT/.Trash
export ARCHIVE=$MOS_ROOT/.Archive

# Remaps rm to r
rm() {
  for arg in $@; do
    if [[ $arg != "-*" ]]; then
      r $arg
    fi
  done
}

# Remove Utility: Remove
# r file : Move file to trash
r() {
  trash=$TRASH/$(timestamp)
  md $trash
  if [[ $1 == "" ]]; then
    mv * $trash
  elif [[ -a $1 ]]; then
    mv $@ $trash
  fi
  l
}

# Remove Utility: Remove Undo TODO Create history aware Undo TODO Doesn't work when removed nested file
# ru : Undo the last removal
ru() {
  m $TRASH/$(ls $TRASH | tail -1)/*(D) .
	rmdir $TRASH/$(ls $TRASH | tail -1)
}

# Remove Utility: Remove List
# rl : List files in trash
rl() {
  l $TRASH
}

# Remove Utility: Remove Empty
# re : Empty files in trash
re() {
  command rm -rf $TRASH/*
}

# Remove : Archive
# ra a : Archive file a
ra() {
  archive=$ARCHIVE/$(timestamp)
  md $archive
  if [[ $1 == "" ]]; then
    mv * $archive
  elif [[ -a $1 ]]; then
    mv $@ $archive
  fi
  l
}

# Cat Utility: Cat Line
# catl file 1 : Cat file line 1
catl() {
  sed -n $2p $1
}

# Write Utility: Insert Line
# ins file "text" : Insert "text" into line 1 of file
ins() {
  sed -i "1i$2" $1
}

fw() {
  while true; do
    inotifywait -r -e modify,move,create,delete $1 &> /dev/null && eval $2
  done
}

# }}}

# Configuration Files {{{

export RC=$MOS_ROOT/.rc
export ZSHRC=$RC/.zshrc
export VIMRC=$RC/.vimrc
export TMUXRC=$RC/.tmux.conf
export MUTTRC=$RC/.muttrc
export XMODMAP=$RC/.Xmodmap
export DIRCOLORSRC=$RC/.dir_colors

# TODO msh should not determine the placing of rc files
#dl $ZSHRC ~
#dl $VIMRC ~
#dl $TMUXRC ~
#dl $MUTTRC ~
#dl $DIRCOLORSRC ~

# Configure Vi
rcv() {
  o $VIMRC
}

# Configure Tmux
rct() {
  vi $TMUXRC
  tmux source-file $TMUXRC
}

# Configure Mutt
rcm() {
  vi $MUTTRC
}

# Re-source Xmodmap
keyon() {
  xmodmap $XMODMAP
}

# }}}

# Terminal {{{

alias tmo='tmux new -s'
alias tmn='tmux new -ds'
alias tmk='tmux kill-session -t'
alias tma='tmux attach -t'
alias tmr='tmux attach -d -t'
alias tms='tmux switch -t'
alias tml='tmux ls'
alias tmd='tmux detach'
alias tmw='tmux neww -t'
alias tmg='tmux selectw -t'
alias tmt='tmux send -t'

b() {
 clear
 figlet -f big -w 160 $@
}

std() {

  mr

  if [[ $1 = "" ]]; then
    tmux kill-server
  fi

  BASE="$HOME"
  cd $BASE

  if [[ $1 = "" || $1 = "1" ]]; then
    tmk H
    tmn H
    tmw H:2
    tmt H:1 "ssse" C-m
    tmt H:2 "work" C-m
    tmg H:1
  fi

  if [[ $1 = "" || $1 = "2" ]]; then
    tmk L
    tmn L
    tmg L:1
  fi

  if [[ $1 = "" || $1 = "3" ]]; then
    tmk J
    tmn J
    tmt J:1 "ss" C-m
    tmt J:1 "pj" C-m
    tmg J:1
  fi

  if [[ $1 = "" || $1 = "4" ]]; then
    tmk K
    tmn K -n K
  fi

  tma J
}

# }}}

# {{{ Irssi

dh() {
  dehilight
}

clog() {
  if [[ $1 = "" ]]; then
    #pn "for file in $(find ~/.irclogs -type f); do ls -l $file; done | grep $(date +%F) | cut -d \" \" -f 8 | grep \"\/[^\/]*@\" | nl"
    pn clog "for file in $\(ls\); do echo $file; done"
  else
    o $(for file in $(find ~/.irclogs -type f); do ls -l $file; done | s $(date +%F) | s $1 | cut -d " " -f 8 | s "\/[^\/]*@")
  fi
}

# }}}

# Echo {{{

# Echo
# e text : Echo "text"
e() {
  echo $@
}

ev() {
  eve "e \$$1:u"
}

# Eval Echo
# eve {1..3}' r' : Evaluate "1 r" "2 r" "3 r"
eve() {
  eval $(e $@)
}

efp() {
  echo $PWD/$1
}

# }}}

# Awk {{{

# Awk : Awk Line
# al 1 10 : Print from line 1 to 10
al() {
  SNA="NR < 0"
  for sn in $SN; do
    SNA+=" || NR == $sn"
  done
  if [[ $MSH_THEME == DARK ]]; then 
    ALTBG=$BGBLACK
  else 
    ALTBG=$BGWHITE
  fi
  awk "NR >= $1 && NR <= $2 && ( $SNA ) {printf selected}
       NR >= $1 && NR <= $2 && NR % 2 == 0 {print altbg \$0 finish}
       NR >= $1 && NR <= $2 && NR % 2 == 1 {print \$0}" \
       selected=$BRRED altbg=$ALTBG finish=$FINISH
}

# Awk : Awk Column
# ac 3 : Print column 3
ac() {
	awk "{print \$$1}"
}

# Process : Process Line
# pl 2 10 : Print from line 2 to 10
# pl 2 : Print from line 2 to the end
pl() {
  if [[ $2 == "" ]]; then
    awk "NR >= $1 {print \$0}"
  else
    awk "NR >= $1 && NR <= $2 {print \$0}"
  fi
}

# }}}

# Search {{{

# Search
# s apple shopping : Search for "apple" in file "shopping" with coloured highlights on if suitable
s() {
  grep -Ei --line-buffered --color=auto $@
}

# Search : Colour
# s apple shopping : Search for "apple" in file "shopping" with coloured highlights always on
sc() {
  grep -Ei --line-buffered --color=always $@
}

# Search : Inverse
# si apple shopping : Inversely search for "apple" (exclusing matches) in file "shopping"
si() {
  s -v $@
}

# Search : Local
# sl apple : Search for "apple" locally in all files (recursive, case insensitive)
sl() {
  if [[ $2 = "" ]]; then
    if $MSH_AUTO_EXCLUDE; then
      pn s "grep --color=always -EirnI --exclude-dir={$MSH_AUTO_EXCLUDE_GLIST} \"$1\" ."
    else
      pn s "grep --color=always -EirnI \"$1\" ."
    fi
  else
    if $MSH_AUTO_EXCLUDE; then
      pn s "grep --color=always -EirnI --include=\"$2\" --exclude-dir={$MSH_AUTO_EXCLUDE_GLIST} \"$1\" ."
    else
      pn s "grep --color=always -EirnI --include=\"$2\" \"$1\" ."
    fi
  fi
}

gs() {
  if [[ $2 = "" ]]; then
    pn gs "grep --color=always -EirnI --exclude-dir={.svn,testsrc,target,.classpath} --exclude=\"*.sql\" \"$1\" ."
  else
    pn gs "grep --color=always -EirnI --exclude-dir={.svn,testsrc,target,.classpath} --include=\"*$2*\" \"$1\" ."
  fi
}

gsa() {
  if [[ $2 = "" ]]; then
    eval $(echo "grep --color-always -EirnI --exclude-dir={.svn,testsrc,target,.classpath,inf} \"$1\" .") | nl
  else
    eval $(echo "grep --color-always -EirnI --exclude-dir={.svn,testsrc,target,.classpath,inf} --include=\"*$2*\" \"$1\" .") | nl
  fi
}

gsp() {
  eval $(echo "grep --color-always -EirnI --exclude-dir={.svn,testsrc,inf} $@ .")
}

gf() {
  pn s "grep \"^[^C].*($1)\" -rin . --include=\"*.f\" -B9999 | grep \"\s\sprogram\s|\s\sfunction\s|\s\ssubroutine\s|^[^C].*($1)\" -i | grep \"^[^C].*($1)\" -B1 -i | grep -v \"\-\-\""
}

gjf() {
  gs "(private|protected|public)[^=]*$1[^\(]*;"
}

WHC=$MOS_TMP/wh/current
WHH=$MOS_TMP/wh/history

wh() {
  if [[ ! -d $WHH ]]; then
    mkdir -p $WHH
  fi
  if [[ -f $WHC ]]; then
    mv $WHC $WHH/$(ls -1 $WHH | wc -l)
  fi
  $(whs $1) > WHC
  cat $MOS_TMP/wh/current | nl
}

whs() {
  gs "private ($1|List<$1>) " | sed "s/^.*\///" | sed "s/\..*List.*$/ */" | cut -d "." -f 1
}

# }}}

# Find {{{

# Find : Find Locate
# fl intellij : Find the system file with the keyword "intellij" in its name
fl() {
  pn fl "locate -bi $1 | si .Trash | si .cache | s $1"
}

# Find by full file name
f() {
	if [[ $2 == '' ]]; then
		fdir="."
	else
		fdir=$2
	fi
  if $MSH_AUTO_EXCLUDE; then
    pn f "find $fdir -regex '.*/$1' $MSH_AUTO_EXCLUDE_FLIST ${@:3}"
  else
    pn f "find $fdir -regex '.*/$1' ${@:3}"
  fi
}

# Find by partial name
fp() {
  f ".*"$1"[^\/]*" ${@:2}
}

# Find source by full PascalCase abbreviated name
fa() {
  f $(ab $1)
}

# Find source by partial PascalCase abbreviated name
fpa() {
  f $(pab $1)
}

# }}}

# Process {{{

# Process : Process Find
# pf java tss : List all processes that includes "java" and "tss" in its details, order significant
pf() {
  ps -ef | si grep | s $(kw $@)
}

# Process : Process Kill
# pk java tss : Kill all processes that includes "java" and "tss" in its details, order significant
pk() {
	case $OS in
			GNU) pf $@ | ac 2 | xargs kill -9;;
			BSD) pf $@ | cut -d " " -f 4 | xargs kill -9;;
	esac
}

# Process : Process Kill Background
# pkb fpa : Kills all background processes that involve fpa
pkb() {
	for job in $(jobs -l | grep $1 | ac 3); do
		kill $job
	done
}

# Process : Process Kill Background All
# pkba : Kills all background processes
pkba() {
	kill ${${(v)jobstates##*:*:}%=*}
}

# }}}

# Remote {{{

# Remote : Remote Copy
# rmc a:/b/ c:/d : Remotely copy from a:/b to c:/d
# rmc a:/b/ c:/d *.zip: Remotely copy *.zip from a:/b to c:/d
rmc() {
  if [[ $3 != "" ]]; then
    rsync -rLpt $1 $2 --include=$3 --exclude="*"
  else
    rsync -rLpt $1 $2
  fi
}

# Remote : Remote Update
# rmu a:/b/ c:/d : Remotely update c:/d to match a:/b
# rmu a:/b/ c:/d *.zip: Remotely update c:/d to match a:/b/*.zip
rmu() {
	if [[ $2 == "" ]]; then
    rsync -rLpt --delete-excluded $1 .
  elif [[ $3 == "" ]]; then
    rsync -rLpt --delete-excluded $1 $2
  else
    rsync -rLpt --delete-excluded $1 $2 --include="$3" --exclude="*"
  fi
}

# Remote : Remote Mount
# rmm a:/b/ c:/d : Remotely mount a:/b/ to c:/d
rmm() {
  md $2
  sshfs $1 $2
}

# Remote : Remote Unmount
# rmum a:/b/ : Remotely unmount a:/b/
rmum() {
  fusermount -u $1
  r $1
}

# }}}

# Directory/Disk {{{

# Directory : Make Directory
md() {
  mkdir -p $@
}

# Directory : Directory
# d ex : Move to directory "ex" even if it doesn't exist
d() {
  if [[ $1 == "" ]]; then
    1=$MOS_ROOT
  fi
  if [[ ! -d $1 && $1 != "-" ]]; then
    mkdir -p $@
  fi
  touch -a $1
  builtin cd $1
  l
}

# Disk : Usage
# du : Show a break down of the disk usages for the current directory
du() {
  #/usr/bin/du -h --max-depth=1

  # Double du
  #/usr/bin/du --max-depth=1 | sort -nr | cut -f2 | xargs -d '\n' du -sh

  # Schwartzian transform
  /usr/bin/du -h --max-depth=1 | perl -e '%byte_order = ( G => -3, M => -2, K => -1, k => -1 ); print map { $_->[0] } sort { $byte_order{$a->[1]} <=> $byte_order{$b->[1]} || $b->[2] <=> $a->[2] } map { [[ $_, /([MGK])/, /(\d+)/ ]] } <>' | head -30
}

# Disk : Free
# df : Show free disk space
df() {
  /bin/df -h
}


# Disk : Free Root
# dfr : Show free disk space for the device mounted on root (/)
dfr() {
  df | s /$ | ac 4
}

# }}}

# Open {{{

# Open : Open File Type (Variable)
# OPT=(png eog) : "o a.png" executes "eog a.png"
typeset -A OFT
OFT=(png eog jpg eog pdf evince zip uz tar uz gz uz jar oj)

# Open : Open
# o a : Go to into directory or open file in Vi
o() {
  if [[ $1 = "" ]]; then
    oh
    return
  fi
  e $(efp $1) >> $MSH_HISTOPEN
  if [[ -d $1 || $1 = "-" ]]; then
    d $1
  elif [[ -f $1 ]]; then
    wtt $(rnode $1 "/" 0)
    e $(efp $1) >> $MSH_HISTOPENFILE
    if [[ -x $1 ]]; then
      $1
    else
      for ft in ${(k)OFT}; do
        if [[ $1 = *.$ft ]]; then
          $OFT[$ft] $1
          return
        fi
      done
      if [[ $2 = "" ]]; then
        vi $1
        pg
      else
        vi +$2 $1
        pg
      fi
    fi
  fi
}

oj() {
  java -jar $1
}

# History Utility : Open History File
# ohf histfile [keyword] : Show open history for a specific history file
ohf() {
  if [[ $2 == "" ]]; then
    pn oh "cr $1 | uniq -c"
    #| sort | uniq -c | sort -nr"
  else
    pn oh "cr $1"
  fi
}

# History : Open History
# ofh : Show open history
oh() {
  ohf $MSH_HISTOPEN $1
}

# History : Open File History
# ofh : Show open file history
ofh() {
  ohf $MSH_HISTOPENFILE $1
}

# History : Command History
# ch [xml] : Show command history [that involves xml]
ch() {
  if [[ $1 == "" ]]; then
    pn ch "cr $MSH_HISTCMD | si \"^[^ ]*$\" | si \"^ch$\" | si \"^ch \" | uniq -c"
  else
    pn ch "cr $MSH_HISTCMD | si \"^[^ ]*$\" | si \"^ch$\" | si \"^ch \" | s "$(echo $1 | esk)" | uniq -c"
  fi
}

chd() {
  cr $MSH_HISTCMD | si "^[^ ]*$" | si "^ch$" | si "^ch " | si "^chd" | s "$(echo $1 | esk)" | uniq | head -$2 | tail -1
}

# History : History Clear
# hc : Clear all history
hc() {
  : > $MSH_HISTCMD
  : > $MSH_HISTOPEN
  : > $MSH_HISTOPENFILE
}

# History : History Simplify
# hs : Simplify command history file by removing the old duplicates
hs() {
	cat -n $MSH_HISTCMD | sort -r | sort --key=2.1 -b -u | sort -n | cut -c8- > $MSH_HISTCMD
}

# Find by full name and open with Vi
of() {
  f $1
  rn 1
}

# Find source by partial name and open with Vi
ops() {
  vi $(fps $1 | unl)
}

# Find source by full PascalCase abbreviated name and open with Vi
oa() {
  vi $(fa $1 | awk '{print $2}')
}

# Find source by partial PascalCase abbreviated name and open with Vi
opa() {
  vi $(fpa $1 | awk '{print $2}')
}

# Find executable in PATH and open with Vi
ow() {
  vi $(w $1)
}

# }}}

# Numbered Shortcut {{{

# Numbered Shortcut : Selected Numbers Initialise
# sni : Reset the selected numbers
sni() {
   SN=()
   SI=()
}
sni

# Numbered Shortcut : Add Number
# an 12 : Add number 12 into the number list
an() {
  for var in $@; do
    SN+=$var
    SI+=$(catlbnc $var)
  done
  pgp
}

# Numbered Shortcut : Clear Numbers
# cn : Remove all selected numbers
cn() {
  sni
  pgp
}

# Numbered Shortcut : Selected Numbers
# sn m a : Move all selected items to a
sn() {
  for si in $SI; do
    eve $(tn $si $@)
  done
  cn
}

pn() {
  echo $1 > $MOS_TMP/stdbuf/$$.cmd
  evb ${@:2} $PN_PIPE
  pg
}

pnc() {
  c $MOS_TMP/stdbuf/$$.cmd
}

fn() {
  catlbnc $1 | xargs ${@:2}
}

# Translate Numbered Shortcut
# TODO each case could be a new function that's evaluated here, e.g. tn_vh instead of vh in case
# MAYBE end of action reprint should be done as part of tn (vb, vbd, going back to vb should be done as part of tn not vbd)
tn() {
    n=$1
    case $(pnc) in
        d) e cd +$1;;
        t) case $2 in
               r) e r $(rnode $n " " 0);;
               "") e o $(rnode $n " " 0);;
					 esac;;
        note) e o $(rpc | sed -n "$1"p | cut -d "-" -f 3 | cut -d " " -f 2);;
        l) case $2 in 
               r) e r "$(echo $n | awk '{print $9}')";;
               "") e o "$(echo $n | awk '{print $9}')";;
               *) e $2 "$(echo $n | awk '{print $9}')" ${@:3};;
           esac;;
        lt) e o $(echo $n | awk '{print $9}');;
        fl) e o $n;;
        f) e o $n;;
        fa) e o $n;;
        fp) e o $n;;
        fpa) e o $n;;
        tca) e vimdiff $n $PJ_ROOT/$MB/$n;;
        oh) e o $(rnode $n " " 0);;
        ch) e $(e $n | cut -c 9-);;
        s) e o $(echo $n | cut -d ":" -f 1) $(echo $n | cut -d ":" -f 2);;
        gs) e o $(echo $n | cut -d ":" -f 1) $(echo $n | cut -d ":" -f 2);;
        gf) if echo $n | grep -q "^[^ ]*:"; then delim=:; else delim=-; fi; o $(echo $n | cut -d $delim -f 1) $(echo $n | cut -d $delim -f 2);;
        wh) e wh $(echo $n | cut -d " " -f 1);;
        clog) e o $n;;
				vb) case $2 in 
								"") if [[ $n == *remotes*origin* ]]; then e vbt $(echo $n | sed 's/remotes.origin.//g'); else e vbs $n; fi;;
								d) e vbd $(e $n | sed 's/\*//g');;
								df) e vbdf $(e $n | sed 's/\*//g');;
                h) e vbh $(e $n | sed 's/\*//g');;
						esac;;
				vh) case $2 in
								"") if [[ $(vt) == "GIT" ]]; then e vhd $(e $n | ts ^[^a-z0-9]* | cut -d " " -f1); fi;;
								s) if [[ $(vt) == "GIT" ]]; then e vbs $(e $n | ts ^[^a-z0-9]* | cut -d " " -f1); fi;;
								a) if [[ $(vt) == "GIT" ]]; then e vha $(e $n | ts ^[^a-z0-9]* | cut -d " " -f1); fi;;
								u) if [[ $(vt) == "GIT" ]]; then e vhu $(e $n | ts ^[^a-z0-9]* | cut -d " " -f1); fi;;
						esac;;
        vbmd) case $2 in
								"") if [[ $(vt) == "GIT" ]]; then e vhd $(e $n | cut -c2- | cut -d " " -f1); fi;;
								a) if [[ $(vt) == "GIT" ]]; then e vha $(e $n | cut -c2- | cut -d " " -f1); fi;;
								ai) if [[ $(vt) == "GIT" ]]; then e vhai $(e $n | cut -c2- | cut -d " " -f1); fi;;
						esac;;
				vs) case $2 in
								"") if [[ $(vt) == "GIT" ]]; then e vd $(e $n | cut -c4-); fi;;
								"o") if [[ $(vt) == "GIT" ]]; then e o $(e $n | cut -c4-); fi;;
								"r") if [[ $(vt) == "GIT" ]]; then e vr $(e $n | cut -c4-); fi;;
								"a") if [[ $(vt) == "GIT" ]]; then e va $(e $n | cut -c4-); fi;;
						esac;;
        vw) case $2 in
								"") if [[ $(vt) == "GIT" ]]; then e vwv $(e $n | cut -d: -f1); fi;;
								"a") if [[ $(vt) == "GIT" ]]; then e vwa $(e $n | cut -d: -f1); fi;;
								"u") if [[ $(vt) == "GIT" ]]; then e vwu $(e $n | cut -d: -f1); fi;;
								"d") if [[ $(vt) == "GIT" ]]; then e vwd $(e $n | cut -d: -f1); fi;;
								"p") if [[ $(vt) == "GIT" ]]; then e vwp $(e $n | cut -d: -f1); fi;;
						esac;;
				me) e "vi $MSH/msh-$n/$n.msh -s \"$MOS_TMP/rc.vi\" && mr";;
        *) echo Done nothing.;;
    esac
}

# Numbered shortcut: Run numbered shortcut
# rn 2: Run the numbered shortcut for line 2 of the output of the previous command
rn() {
# Listing numbers to add to selected list quickly
  cmd=()
  MSH_PAGER_ON=false
  for arg in $@; do
    if [[ $arg = [0-9]* ]]; then
      an $arg
    else
      cmd+=$arg
    fi
  done
  sn $cmd
  unset cmd
  MSH_PAGER_ON=true
  pgp
}

for ((i = 0; i < 10000; i++)); do
  alias $i="rn $i"
done

for ((i = 0; i < 10000; i++)); do
  alias f$i="fn $i"
done

for ((i = 0; i < 10000; i++)); do
  alias a$i="an $i"
done

# }}}

#}}}

#### General Developement {{{

# General Navigation {{{

# Go to projects directory, depending on the development mode
pj() {
  cd $PJ_ROOT
  if [[ -d $PJ ]]; then
    o $PJ
  fi
}

pjr() {
  o $PJ_ROOT
}

# Go to the head project directory, depending on the development mode
hd() {
  cd $PJ_ROOT
  if [[ -d $HD ]]; then
    cd $HD
  fi
}

# Go to service directory
sv() {
  o $SV_ROOT
  if [[ ! -d $SV ]]; then
    wtt "sv not found"
    return 1
  fi
  o $SV
  o current
  wtt sv
} 

# }}}

# SSH {{{

# Server : Haoyangnz
# hynz : Connect to haoyangnz
hynz() {
	ssh haoyangnz.ddns.net
}

sci() {
  ssh-copy-id $1
}

# }}}

# SQL {{{

# Run SQL with credentials and database
sql() {
  if [[ $1 = "" ]]; then
    mysql -u$MSH_SQL_USER -p$MSH_SQL_PASS
  elif [[ $2 == "" ]]; then
    DB=${SQL_PREFIX}$1
    mysql -u$MSH_SQL_USER -p$MSH_SQL_PASS $DB
  else
    mysql -u$MSH_SQL_USER -p$MSH_SQL_PASS $@
  fi
}

# Find table in databases
sqlf() {
  for database in $(sqle "show databases" | s $SQL_PREFIX); do
    if table=$(sql $database -e "show tables" | s $(pab $1)); then
      e $database
      e $table
      e
    fi
  done
}

# SQL : SQL List Database
# sqlld : List all databases under the SQL_PREFIX
sqlld() {
  sqle "show databases" | s "^$SQL_PREFIX" | sed "s/^$SQL_PREFIX//"
}

# Rename SQL database
sqlmv() {
  sqle "create database ${SQL_PREFIX}$2"
  for table in `sql -B -N -e "show tables" ${SQL_PREFIX}$1`; do 
    sqle "rename table ${SQL_PREFIX}$1.$table to ${SQL_PREFIX}$2.$table"
  done
  sqle "drop database ${SQL_PREFIX}$1"
}

# Drop SQL database
sqlrm() {
  sqle "drop database "${SQL_PREFIX}$1""
}

# Create SQL database
sqlmk() {
  sqle "create database "${SQL_PREFIX}$1""
}

# Import SQL script to database
# $2 database dump suffix
# sqli tailim : Imports mes_8_csc/man_tailim.sql to mes_8_csc/man if java revision is mes-8
sqli() {
  if [[ $1 != "" ]]; then
    sql_suffix=_$1
  else
    unset sql_suffix
  fi
  for db in $(sqlld); do
    sqlfile=$SQL_PREFIX$db$sql_suffix.sql
    if [[ -f $sqlfile ]]; then
      sqlrm $db
      sqlmk $db
      sql $db < $sqlfile
    else
      e Cannot find $sqlfile
    fi
  done
  wtt "sqli [DONE]"
}

# Export SQL database to script
# $1 database dump suffix
# sqlo tailim : Exports mes_8_csc/man to mes_8_csc/man_tailim.sql if java revision is mes-8
sqlo() {
  if [[ $1 != "" ]]; then
    SQL_SUFFIX=_$1
  fi
  for db in $(sqlld); do
    sqlfile=$SQL_PREFIX$db$SQL_SUFFIX.sql
    mysqldump --skip-tz-utc -u$MSH_SQL_USER -p$MSH_SQL_PASS $SQL_PREFIX$db > $sqlfile
  done
  wtt "sqlo [DONE]"
}

# Show SQL process list
sqlp() {
  sqle "show processlist"
}

# Execute SQL in database
sqle() {
  if [[ $(echo $@) == *"database"* ]]; then
    eval "sql -e \"$@\""
  else
    table=$(echo $@ | sed "s/^.*\(from\|desc\|update\) //" | cut -d " " -f1)
    database=$(sqlf $table | pl 1 1)
    eval "sql $database -e \"$@\""
  fi
}

# SQL Utility : SQL Query
# sqlq "Query" : query the database with Simplified-SQL
sqlq() {
  if [[ $1 == "" ]]; then
    while read table; do
      sqlqe $table
    done
  else
    sqlqe $table
  fi
}
sqlqe() {
  result=$(sqlf $1)
  database=$(e $result | pl 1 1)
  tables=$(e $result | pl 2)
  if ! table=$(e $tables | s ^$1$); then
    table=$(e $tables | pl 1 1) # Use the first match if no exact match
  fi
  count=$(sqle "select count(*) from $table" | head -3 | tail -1)
  (( column = $(sqle "desc $table" | wc -l) - 1 )) 
  (e $table@$database: $count rows and $column columns;
   sqle "select * from $table \G") | vi -
}

# SQL Utility: Explain a SQL table
# sqlt
sqlt() {
  if [[ $1 = "" ]]; then
    while read table; do
      sqlte $table
    done
  else
    sqlte $1
  fi
}
sqlte() {
  database=$(sqlf $1)
  sql $database -e "select * from $1 limit 1 \G;" | vi -
}

# }}}

# General Programming {{{

# Doc Tag : Search
# dts todo : Search for all instances of where "TODO" occurs in comments (CAVEAT Currently only works for Java, INTENT allow language detection)
dts() {
  sl "//(.* )?$1"
}

# }}}

# Version Control {{{
unsvn () {
  find . -name ".svn" | xargs /bin/rm -rf
}

reapply() {
  dir=$(pwd)
  cd ..
  rm -rf $dir
  mv $dir.bak $dir
  cd $dir
  dp
}

revert() {
  dir=$(pwd)
  cd ..
  mv $dir $dir.bak
	vu
  cd $dir
  dp
}

# SVN Revert Utility
# rv : Revert all changes and remove unversioned files
rv() {
  if [[ -d .git ]]; then
    git reset --hard
  fi
  if [[ -d .svn ]]; then
    svn -R revert .
    svn st
    svn st | s \? | awk '{print $2}' | xargs rm -rf
    svn st
  fi
}

# SVN Merge Out Utility
# mo : Merge out the changes from head branch to base
rmo() {
  mcv MMB $MHD
  mcv JMB $JHD
  pj
  svn merge $PJ_ROOT/$MB
}

# SVN Merge In Utility
# rmi : Merge in the changes from base to head branch
rmi() {
  mcv MMB $MPJ
  mcv JMB $JPJ
  hd
  if [[ $1 = "" ]]; then
    svn merge --reintegrate $PJ_ROOT/$MB
  else
    svn merge -c r$1 $PJ_ROOT/$MB
  fi
}

# SVN Tree Conflict: List Add Conflicts
# tca : List tree conflicts for "local add, incoming add"
tca() {
  svn st | s ">   local add, incoming add upon merge" -B1 | si ">" | si "\-\-" | cut -c9- | nl
}

# SVN Tree Conflict: Resolve Identical Add Conflicts
# tcar : Resolve tree conflicts for "local add, incoming add" by accepting local, where the files are identical
tcar() {
  for tc in $(svn st | s ">   local add, incoming add upon merge" -B1 | si ">" | si "\-\-" | cut -c9-); do
    if [[ "$(diff $tc $PJ_ROOT/$MB/$tc)" = "" ]]; then
      svn resolve --accept working $tc
    fi
  done
}

# SVN Tree Conflict: Accept Incoming
# tcaa : Accept incoming files for tree conflicts for "local add, incoming add"
tcaa() {
  for tc in $(svn st | s ">   local add, incoming add upon merge" -B1 | si ">" | si "\-\-" | cut -c9-); do
    cp $PJ_ROOT/$MB/$tc $tc
  done
}

# SVN Tree Conflict: List Other Conflicts (Non-add)
# tco : List Tree conflicts other than "local add, incoming add"
tco() {
  svn st | si ">   local add, incoming add upon merge" | s ">()" -B1 | si ">" | si "\-\-" | cut -c9-
}

svncomment() {
  svnf propset svn:log --revprop -r $1 \"$2\" $SVN
}

svnlog() {
  if [[ $1 = "" ]]; then
    svnf log | head -5000 | head -30
  else
    svnf log | head -5000 | s -C2 $1 | head -30
  fi
}

svndi() {
  svn di -c $1 *
}

# Version Control : Type
# vt : Show repository type (either GIT or SVN) based on current directory and also preferred mode
vt() {
	if [[ ! -d .svn ]] && evn "git rev-parse --git-dir" ; then
		e GIT
	elif [[ -d .svn ]] && ! evn "git rev-parse --git-dir" ; then
		e SVN
	elif [[ ! -d .svn ]] && ! evn "git rev-parse --git-dir" ; then
		e N/A
	else
		e $MSH_PREFERRED_REPOSITORY_TYPE
	fi
}

# Version Control : Branch {{{

# Version Control : Branch
vb() {
  if [[ $1 == "" ]]; then
    _vb
  elif git rev-parse --verify $1; then
    vbs $1
  else
    vbn $1
  fi
}
_vb() {
	case $(vt) in
		GIT) pn vb "git branch --color -a $@";;
		N/A) e current directory not under version control;;
		*) e vb is not supported for your repository type;;
	esac
}

# Version Control : Branch Publish
vbp() {
	case $(vt) in
		GIT) git push -u origin $(vbc);;
		N/A) e current directory not under version control;;
		*) e vbp is not supported for your repository type;;
	esac
}

# Version Control : Branch New
vbn() {
	case $(vt) in
		GIT) git checkout -b $@;;
		N/A) e current directory not under version control;;
		*) e vbn is not supported for your repository type;;
	esac
	vb
}

# Version Control : Branch Rebase New
# vbrn newbase : Create a new branch from "newbase" and cherry pick all unmerged commits (based on the current branch's parent) from the current branch into "newbase"
# vbrn newbase1 newbase2 newbase3: Do vbrn for each newbase
vbrn() {
	case $(vt) in
		GIT)
			vbrn_feature=$(vbc)
			vbrn_feature_parent=$(vbcp)
			for vbrn_newbase in $@; do
				vb $vbrn_newbase
				vu
				vb $vbrn_feature-$vbrn_newbase
				for cherry in $(git cherry $vbrn_feature_parent $vbrn_feature | cut -d" " -f2); do
					git cherry-pick $cherry;
					if [[ $(git ls-files --unmerged | wc -l) -gt 0 ]]; then
					vce
					vca
					fi
				done
				vp
			done
			;;
		N/A) e current directory not under version control;;
		*) e vbrn is not supported for your repository type;;
	esac
	vb
}


# Version Control : Branch Track
# vbt feature : Check out branch "feature" from origin into a local branch "feature"
vbt() {
	case $(vt) in
		GIT) git checkout -b $1 origin/$1;;
		N/A) e current directory not under version control;;
		*) e vb is not supported for your repository type;;
	esac
	vb
}

# Version Control : Branch Switch
vbs() {
	case $(vt) in
		GIT) git checkout $1;;
		SVN) svn sw $(svn info | s URL | cut -d " " -f 2 | sed -r 's/branches\/[^\/]*\//branches\/'$1'\//');;
		N/A) e current directory not under version control;;
		*) e vb is not supported for your repository type;;
	esac
	vb
}

# Version Control : Branch Merge
# vbm : Merge from the parent branch
# vbm feature : Merge from the "feature" branch into the current branch
vbm() {
	case $(vt) in
		GIT) if [[ $1 == "" ]]; then git merge $(vbcp); else git merge $1; fi;;
		SVN) svn merge -c $1 .;;
		N/A) e current directory not under version control;;
		*) e vb is not supported for your repository type;;
	esac
	vb
}

# Version Control : Branch History
# vbh : Show version control history for the current branch
vbh() {
	case $(vt) in
		GIT) pn vh "git log --graph --full-history --color --abbrev-commit --decorate --date=relative --format=format:'%C(blue)%h%C(reset) - %C(green)(%ar)%C(reset) %C(bold red)%s%C(reset) %C(cyan)- %an%C(reset)%C(yellow)%d%C(reset)' $@";;
		N/A) e current directory not under version control;;
		*) e vh is not supported for your repository type;;
	esac
}


# Version Control : Branch Merge Diff Ahead
# vbmda master : Show all commits that is in the current branch but isn't in master (thus ahead of master)
vbmda() {
  if [[ $1 == "" ]]; then
    1=$(vbcp)
  fi
	pn vbmd "git rev-list --left-right --no-merges --pretty=oneline ${1}... | s '>'"
}

# Version Control : Branch Merge Diff Behind
# vbmdb master : Show all commits that isn't in the current branch but is in master (thus behind master)
vbmdb() {
  if [[ $1 == "" ]]; then
    1=$(vbcp)
  fi
	pn vbmd "git rev-list --left-right --no-merges --pretty=oneline ${1}... | s '<'"
}

# Version Control : Branch Merge Diff Incoming Count
# vbmdic : Show how many commits coming in when merging from the parent branch (behind the parent branch)
vbmdic() {
	git rev-list --left-right --count --no-merges $(vbcp)... | cut -f1
}

# Version Control : Branch Merge Diff Outgoing Count
# vbmdoc : Show how many commits going out when merging to the parent branch (ahead of the parent branch)
vbmdoc() {
	git rev-list --left-right --count --no-merges $(vbcp)... | cut -f2
}

# Version Control : Branch Delete
# vbd feature : Delete branch "feature"
vbd() {
	case $(vt) in
		GIT) 
			if [[ $1 == $(vbc) ]]; then
				# Trying to delete current branch, switch to the parent branch first
				git checkout $(vbcp)
				git branch -d $@
			else
				git branch -d $@
			fi
			;;
		N/A) e current directory not under version control;;
		*) e vbd is not supported for your repository type;;
	esac
	vb
}

# Version Control : Branch Delete Force
# vbdf feature : Delete branch "feature" by force even if the branch hasn't been merged
vbdf() {
	case $(vt) in
		GIT) 
			if [[ $1 == $(vbc) ]]; then
				# Trying to delete current branch, switch to the parent branch first
				git checkout $(vbcp)
				git branch -D $@
			else
				git branch -D $@
			fi
			;;
		N/A) e current directory not under version control;;
		*) e vbdf is not supported for your repository type;;
	esac
	vb
}

# Version Control : Branch Current
# vbc : Get current branch name
vbc() {
	case $(vt) in
		GIT) git rev-parse --abbrev-ref HEAD;;
		N/A) e current directory not under version control;;
		*) e vbc is not supported for your repository type;;
	esac
}

# Version Control : Branch Current Parent
# vbcp : Get the parent branch name of the current branch
vbcp() {
	case $(vt) in
		GIT) 
			vbc_col=$(( $(git show-branch | grep '^[^\[]*\*' | head -1 | cut -d* -f1 | wc -c) - 1 ))
      if [[ $vbc_col -ge 0 ]]; then
        swimming_lane_start_row=$(( $(git show-branch | grep -n "^[\-]*$" | cut -d: -f1) + 1 ))
        git show-branch | tail -n +$swimming_lane_start_row | grep -v "^[^\[]*\[$(vbc)" | grep "^.\{$vbc_col\}[^ ]" | head -n1 | sed 's/.*\[\(.*\)\].*/\1/' | sed 's/[\^~].*//'
      fi
			;;
		N/A) e current directory not under version control;;
		*) e vbc is not supported for your repository type;;
	esac
}

# }}}

# Version Control : History {{{

# Version Control : History Simple
# vhs : Show simplified version control history (omiting linear changes) for all branches
vhs() {
	case $(vt) in
		GIT) git log --graph --full-history --all --color --abbrev-commit --decorate --date=relative --format=format:'%C(blue)%h%C(reset) - %C(green)(%ar)%C(reset) %C(bold red)%s%C(reset) %C(cyan)- %an%C(reset)%C(yellow)%d%C(reset)' --simplify-by-decoration $@;;
		N/A) e current directory not under version control;;
		*) e vhs is not supported for your repository type;;
	esac
}
	
# Version Control : History
# vh : Show version control history for all branches
vh() {
	case $(vt) in
		GIT) pn vh "git log --graph --full-history --all --color --abbrev-commit --decorate --date=relative --format=format:'%C(blue)%h%C(reset) - %C(green)(%ar)%C(reset) %C(bold red)%s%C(reset) %C(cyan)- %an%C(reset)%C(yellow)%d%C(reset)' $@";;
		N/A) e current directory not under version control;;
		*) e vh is not supported for your repository type;;
	esac
}

# Version Control : History Diff
# vhd 5350c00 : See diff for commit 5350c00
vhd() {
	case $(vt) in
		GIT) vd $1^!;;
		N/A) e current directory not under version control;;
		*) e vhd is not supported for your repository type;;
	esac
}

# Version Control : History Apply (Redo/Cherry Pick)
# vha 198f7f8 : Apply (redo/cherry pick) the a commit in history 198f7f8
vha() {
	case $(vt) in
		GIT) git cherry-pick $1;;
		SVN) svn merge -c $1 .;;
		N/A) e current directory not under version control;;
		*) e vha is not supported for your repository type;;
	esac
}

# Version Control : History Apply Interactive (Redo/Cherry Pick)
# vhai 198f7f8 : Apply (redo/cherry pick) the a commit in history 198f7f8 by using interactive hunk selection
vhai() {
	case $(vt) in
		GIT)
        git cherry-pick -n $1
        vce
        git reset
        va
        ;;
		N/A) e current directory not under version control;;
		*) e vhai is not supported for your repository type;;
	esac
}

# Version Control : History Unapply (Undo)
# vhu 198f7f8 : Unapply (undo) the a commit in history 198f7f8
vhu() {
	case $(vt) in
		GIT) git revert $1;;
		SVN) svn merge -c -$1 .;;
		N/A) e current directory not under version control;;
		*) e vhu is not supported for your repository type;;
	esac
}

# }}}

# Version Control : Revision {{{

# Version Control : Revision Branch
# vrb feature : Get rev id for branch 'feature'
vrb() {
	case $(vt) in
		GIT) git rev-parse $1;;
		N/A) e current directory not under version control;;
		*) e vrb is not supported for your repository type;;
	esac
}

# Version Control : Revision Current
# vrc : Get current rev id
vrc() {
	case $(vt) in
		GIT) vrb HEAD;;
		N/A) e current directory not under version control;;
		*) e vrc is not supported for your repository type;;
	esac
}

# Version Control : Revision Current Brief
# vrcb : Get current abbreviated rev id
vrcb() {
	case $(vt) in
		GIT) vrc | cut -c-7;;
		N/A) e current directory not under version control;;
		*) e vrcb is not supported for your repository type;;
	esac
}

# }}}

# Version Control : Status {{{

# Version Control : Status
# vs : Show status of repository
vs() {
	case $(vt) in
		GIT) pn vs "git status -s";;
		SVN) pn vs "svn status";;
		N/A) e current directory not under version control;;
		*) e vs is not supported for your repository type;;
	esac
}

# Version Control : Status Verbose
# vsv : Show status of repository with verbose explanation
vsv() {
	case $(vt) in
		GIT) git status;;
		SVN) svn status;;
		N/A) e current directory not under version control;;
		*) e vsv is not supported for your repository type;;
	esac
}

# Version Control : Status Modified
# vsm : Show modified files in repository
vsm() {
	case $(vt) in
		SVN) svn st | s ^M;;
		N/A) e current directory not under version control;;
		*) e vsm is not supported for your repository type;;
	esac
}

# Version Control : Status Conflict
# vsc : Show files with conflict in repository
vsc() {
	case $(vt) in
		GIT) pn vs "git ls-files --unmerged | cut -f2 | sort | uniq";;
		N/A) e current directory not under version control;;
		*) e vsc is not supported for your repository type;;
	esac
}

# Version Control : Status Untracked Remove
# vsur : Remove all untracked files
vsur() {
	case $(vt) in
		GIT) git status -s | s ^?? | cut -d" " -f2 | xargs rm -rf;;
		N/A) e current directory not under version control;;
		*) e vsur is not supported for your repository type;;
	esac
}

# }}}

# Version Control : WIP (Stash) {{{

# Version Control : WIP (Stash)
# vw : Show WIP list
vw() {
	case $(vt) in
		GIT) pn vw "git stash list";;
		N/A) e current directory not under version control;;
		*) e vw is not supported for your repository type;;
	esac
}

# Version Control : WIP (Stash) Save
# vws : Save dirty changes as a new WIP using interactive hunk selection with generated message
# vws "Change" : Save dirty changes as a new WIP using interactive hunk selection with message "Change"
vws() {
	case $(vt) in
		GIT) git stash save -p $1;;
		N/A) e current directory not under version control;;
		*) e vws is not supported for your repository type;;
	esac
  vw
}

# Version Control : WIP (Stash) Save All
# vwsa : Save all current dirty changes as a new WIP with generated message
# vwsa "Change" : Save all current dirty changes as a new WIP with message "Change"
vwsa() {
	case $(vt) in
		GIT) git stash save $1;;
		N/A) e current directory not under version control;;
		*) e vwsa is not supported for your repository type;;
	esac
  vw
}

# Version Control : WIP (Stash) View
# vwv stash@{1} : View the content of a WIP stash@{1}
vwv() {
	case $(vt) in
		GIT) git stash show -p $1;;
		N/A) e current directory not under version control;;
		*) e vwa is not supported for your repository type;;
	esac
  vw
}

# Version Control : WIP (Stash) Pop
# vwp : Pop (apply and then delete) most recent WIP
# vwp stash@{1} : Pop (apply and then delete) WIP stash@{1}
vwp() {
	case $(vt) in
		GIT) git stash pop $1;;
		N/A) e current directory not under version control;;
		*) e vwp is not supported for your repository type;;
	esac
}

# Version Control : WIP (Stash) Apply
# vwa : Apply most recent WIP
# vwa stash@{1} : Apply WIP stash@{1}
vwa() {
	case $(vt) in
		GIT) git stash apply $1;;
		N/A) e current directory not under version control;;
		*) e vwa is not supported for your repository type;;
	esac
}

# Version Control : WIP (Stash) Un-apply
# vwu stash@{1} : Un-apply WIP stash@{1}
vwu() {
	case $(vt) in
		GIT) git stash show -p $1 | git apply -R;;
		N/A) e current directory not under version control;;
		*) e vwu is not supported for your repository type;;
	esac
}

# Version Control : WIP (Stash) Delete
# vwd stash@{1} : Delete WIP stash@{1}
vwd() {
	case $(vt) in
		GIT) git stash drop $1;;
		N/A) e current directory not under version control;;
		*) e vwd is not supported for your repository type;;
	esac
  vw
}

# }}}

# Version Control : Diff
# vd : Show repository diff in the file system (working tree)
vd() {
	case $(vt) in
		GIT) git diff --color=always -w $@ | less -r;;
		SVN) svn diff $@;;
		N/A) e current directory not under version control;;
		*) e vd is not supported for your repository type;;
	esac
	vs
}

# Version Control : Diff Index
# vdi : Show repository diff in the index (staging area)
vdi() {
	case $(vt) in
		GIT) vd --cached $@;;
		N/A) e current directory not under version control;;
		*) e vds is not supported for your repository type;;
	esac
	vs
}

dt() {
  if [[ -d .git ]]; then
    git difftool $@
  fi
  if [[ -d .svn ]]; then
    svn diff $@
  fi
}

cia() {
  if [[ -d .git ]]; then
    git commit -a --amend -m $1
  fi
}


# Version Control : Add
# va : Add file by using interactive hunk selection
# va file : Add file to version control
va() {
	case $(vt) in
		GIT) if [[ $1 == "" ]]; then git add -p; else git add $1; fi;;
		SVN) svn add $1;;
		N/A) e current directory not under version control;;
		*) e va is not supported for your repository type;;
	esac
	vs
}

# Version Control : Reset
# vr file : Discard changes on file
vr() {
	case $(vt) in
		GIT) if [[ $1 == "" ]]; then git reset --hard; else git checkout -- $1; fi;;
		SVN) svn revert $1;;
		N/A) e current directory not under version control;;
		*) e vr is not supported for your repository type;;
	esac
	vs
}

# Version Control : Update
# vu : Update from remote
vu() {
	case $(vt) in
		GIT) git pull;;
		SVN) svn up;;
		GITSVN) 
			vbc=$(vbc)
      vbcp=$(vbcp)
			if [[ $vbc != $vbcp ]]; then
				vbs $vbcp
			fi
			svn up
			git add .
			vca "svn up"
			if [[ $vbc != $vbcp ]]; then
				vbs $vbc
				vbm $vbcp
			fi
			;;
		N/A) e current directory not under version control;;
	esac
}

# Version Control : Publish
# vp : Publish (push) all outstanding commits to upstream
vp() {
	case $(vt) in
		GIT) git push -u origin $(vbc);;
		SVN) e vp is not supported for SVN;;
		N/A) e current directory not under version control;;
	esac
}

# Version Control : Commit {{{

# Version Control : Commit
# rc "Minor change" : Commit changes with comment "Minor change"
vc() {
	case $(vt) in
		GIT) git commit -m $1;;
		SVN)
			if [[ $(svn st | s "^C") = "" ]]; then
				svn ci ${@:2} -m $1
			else
				echo ci: Couldn\'t commit due to following conflicts
				svn st | s "^C"
				return 1
			fi
			;;
		N/A) e current directory not under version control;;
	esac
}

# Version Control : Commit All
# vca : Commit all changes (including unstaged), prompting for a commit message
# vca "Minor change" : Commit all changes (including unstaged) with comment "Minor change"
vca() {
	case $(vt) in
		GIT)
        if [[ $1 == "" ]]; then
          git add . && git commit -a
        else
          git add . && git commit -a -m $1
        fi
        ;;
		SVN) e vca is not supported for SVN;;
		N/A) e current directory not under version control;;
	esac
}

# Version Control : Commit Publish
# vcp "Minor change" : Commit changes with comment "Minor change" and then publish all outstanding commits
vcp() {
	case $(vt) in
		GIT) vc $1 && vp;;
		SVN) e vcp is not supported for SVN;;
		N/A) e current directory not under version control;;
	esac
}

# Version Control : Commit All Publish
# vcap "Minor change" : Commit all changes (including unstaged) with comment "Minor change" and then publish all outstanding commits
vcap() {
	case $(vt) in
		GIT) vca $1 && vp;;
		SVN) e vcap is not supported for SVN;;
		N/A) e current directory not under version control;;
	esac
}

# Version Control : Conflict Edit
# vce : Edit all conflict files
vce() {
	case $(vt) in
		GIT)
      echo "zR/^<<<
    zz" > $MOS_TMP/vce.vi
      for file in $(git ls-files --unmerged | cut -f2 | sort | uniq); do
        vi $file -s "$MOS_TMP/vce.vi"
          while s "<<<" $file; do
            echo Isn\'t $(s "<<<" $file) another conflict? n to skip.
            read answer
            if [[ $answer == "n" || $answer == "N" ]]; then
              break
            fi
            vi $file -s "$MOS_TMP/vce.vi"
          done
      done
      git add .
      ;;
		SVN) e vce is not supported for SVN;;
		N/A) e current directory not under version control;;
	esac
}

# }}}

co() {
  wtl "Check out"
  if [[ $1 == *git* ]]; then
    git clone $1
  fi
  if [[ $1 == *svn* ]]; then
    svn co $1
  fi
  wtu "Check out [DONE]"
}

svnst() {
  svn di -r 31094:31095 $SVN/trunk/$1 | s Index | cut -d " " -f2
}

svndil() {
  for file in $(svnst $(rnode $(pwd) / 0)); do vimdiff $1/$file $file; done
}

# Blame
bl() {
  svn blame $(find . -name $1) | less
}

# }}}

# Misc Navigation {{{

# Directory : Common
# dc osm : Go to the osm common folder
dc() {
  d $COMMON/$1
}

# Directory : Mount
# dm calypso : Go to the mounted directory calypso
dm() {
  d $MNT/$1
}

# Go to the desktop work directory
work() {
  o $MOS_ROOT/work
  if [[ $1 != "" ]]; then
    d $1
  fi
}

# Directory: Sandbox
# dsb : Go to the Sandbox directory
dsb() {
  d $SANDBOX
}

# Edit note
note() {
  cd $NOTE
  if [[ $1 = "" ]]; then
    t -rt
  else
    vi $1
  fi
}

# }}}

#}}}# }}}

#### General Application {{{

# Google Drive {{{

gd() {
  google docs edit --title $1 --folder Grive --format html --editor google_vim
}

# }}}

# Todo {{{

export TD_TODO=$NOTE/td/todo
export TD_DONE=$NOTE/td/done

# Todo Utility: Edit
# tde : Edit the TODO list
tde() {
  vi $TD_TODO
}

# Todo Utility: Add to the top of the TODO list
tdn() {
  task="$@"
  sed -i "1i$task" $TD_TODO
}

# Todo Utility: Add to the bottom of the TODO list
tda() {
  task="$@"
  echo $task >> $TD_TODO
}

# Todo Utility: Add to the middle of the TODO list
tdi() {
  task="${@:2}"
  sed -i $1i"$task" $TD_TODO
}

# Todo Utility: List tasks on the TODO list
tdl() {
  cat $TD_TODO | nl
}

# Todo Utility: Delete current task
tdd() {
  if [[ $1 = "" ]]; then
    line="1"
  else
    line=$1
  fi
  sed -i "$line"d $TD_TODO
}

# Todo Utility: Finish
# tdf : Finish current task
tdf() {
  ins $TD_DONE "$(catl $TD_TODO 1)"
  tdd
}

# Todo Utility: Undo finish
# tduf : Undo finish of previous task
tduf() {
  ins $TD_TODO "$(catl $TD_DONE 1)"
  sed -i 1d $TD_DONE
}

# Todo Utility: List tasks on the DONE list
tdlf() {
  cat $TD_DONE | tail -30 | nl
}


# }}}

#}}}

#### Other {{{

# Experimental {{{

dj() {
  jarname=`ab $1`".jar"
  find ~/.maven/repository -name $jarname | xargs cp --target-directory .
}

# }}}

# Misc {{{
echo init misc
#export _JAVA_OPTIONS='-Dswing.defaultlaf=com.sun.java.swing.plaf.gtk.GTKLookAndFeel'
#export HISTCONTROL=ignoredups
#export _JAVA_OPTIONS="-Dawt.useSystemAAFontSettings=lcd"

PATH="$PATH:$MOS_BIN:$RC/bin"
if [[ -d "~/projects/maven-misc/bin" ]] ; then
    PATH="~/projects/maven-misc/bin:$PATH"
fi
if [[ -d "/usr/local/java/maven3/bin" ]] ; then
    PATH="/usr/local/java/maven3/bin:$PATH"
fi
if [[ -d "/usr/lib/jvm/maven3/bin" ]] ; then
    PATH="/usr/lib/jvm/maven3/bin:$PATH"
fi
if [[ -d "~/.local/bin" ]] ; then
    PATH="~/.local/bin:$PATH"
fi
#PATH="$MOS_BIN/Sencha/Cmd/3.0.0.250:$PATH"
PATH=$PATH:~/projects/maven-misc/bin
PATH=$PATH:/usr/sbin

PERL_MB_OPT="--install_base \"/home/haoyang.feng/perl5\""; export PERL_MB_OPT;
PERL_MM_OPT="INSTALL_BASE=/home/haoyang.feng/perl5"; export PERL_MM_OPT;

# }}}

#}}}

#### Dependencies {{{ 

# Install Software {{{

# TODO coreutils for BSD
echo init dependencies
case $OS in
	GNU) deps=(zsh tmux vim git tree grc sshfs xclip ssh-copy-id);;
	BSD) deps=(zsh tmux vim git tree grc ssh-copy-id);;
esac
for dep in $deps; do
	wn $dep || pi $dep
done

# }}}

# Directories {{{

echo init directories
md $MOS_TMP $MOS_TMP/stdout $MOS_TMP/stdbuf $MOS_TMP/stderr
md $MNT
md $TRASH $ARCHIVE

# }}}

# Mount {{{

echo init mount
if [[ ! -d $MNT/calypso ]]; then
  md $MNT/calypso
  rmm calypso:/data/kiwiplan/docs/TSS $MNT/calypso
fi

if [[ ! -d $MNT/aurora ]]; then
  md $MNT/aurora
  rmm ssd@aurora:/ $MNT/aurora
fi


# }}}

# }}}

#### Startup {{{ 

# Setup Environment {{{

echo init startup
case $OS in
	GNU) eval $(dircolors ~/.dir_colors);;
	BSD) eval $(gdircolors ~/.dir_colors) && eval $(ls-colors-linux-to-bsd);;
esac

# }}}

# Load Msh Packages {{{

echo init packages
d $MSH
for package in $(ls -d msh-*); do
	echo init $package
	if [[ $package != msh-core && $package != msh-rc ]]; then
    if [[ -a $package/$package.mshrc ]]; then
			if [[ ! -a msh-rc/$package.mshrc ]]; then
				cp $package/$package.mshrc msh-rc
				vi msh-rc/$package.mshrc
			elif [[ $(diff <(cat $package/$package.mshrc | ts =.*) <(cat msh-rc/$package.mshrc | ts =.*) | wc -l) -gt 0 ]]; then
				bur msh-rc/$package.mshrc
				cp $package/$package.mshrc msh-rc
				for var in $(cat msh-rc/$package.mshrc | s export | cut -d' ' -f2 | cut -d= -f1); do
					# XXX Why does evn require the quotes here?
					if evn 's export\ ${var}= msh-rc/$package.mshrc.bak'; then
						sed -i.sedbak 's/^export '$var'=.*$/export '$var'='$(s export\ ${var}= msh-rc/$package.mshrc.bak | cut -d= -f2 | esr)'/g' msh-rc/$package.mshrc
						r msh-rc/$package.mshrc.sedbak
					fi
				done
				r msh-rc/$package.mshrc.bak
				if evn s TODO msh-rc/$package.mshrc
					vi msh-rc/$package.mshrc
				if 
			fi
    fi
    if [[ -a msh-rc/$package.mshrc ]]; then
      source msh-rc/$package.mshrc
    fi
		source $package/*.msh
	fi
done

# }}}

# Goto home or go back {{{

echo init msh
if $NEW; then
  cs
  echo
  d
else
	d $old_dir
fi
NEW=false

# }}}

#}}}

